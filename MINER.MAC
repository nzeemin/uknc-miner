	.TITLE	MINER
	.MCALL	.EXIT
	.ASECT

MAXFLD = <18.*14.>		; Максимальный размер поля, с учётом двух пустых колонок слева/справа

.MACRO	PUSH	RR
	MOV	RR,-(SP)
.ENDM
.MACRO	POP	RR
	MOV	(SP)+,RR
.ENDM

	.=001000
START::
	CLR	@#177560

MENU:
	MOV	#GAMESC, R1	; Строка для подготовки игрового экрана
	CALL	PRINT
	CALL	PAUSE
; Вывод лого
	CALL	DRLOGO
; Вывод текста меню
	MOV	#MENUSC, R1
	CALL	PRINT
MNLOOP:
; Ждём нажатия и крутим случайные числа
1$:	CALL	GETKEY
	BNE	2$
	CALL	RANDOM
	BR	1$
2$:
; Анализ клавиши
	CMP	#130, R0	; 'X'
	BEQ	FINISH
	MOV	#MITEMS, R5
MNLOO1:
	MOV	(R5)+, R1
	BEQ	MNLOOP
	CMPB	R0, R1
	BEQ	STGAME
	ADD	#8., R5
	BR	MNLOO1

FINISH:
	MOV	#EXITSC, R1	; Строка очистки экрана перед выходом
	CALL	PRINT
	.EXIT

; клавиша, ширина, высота, кол-во мин, адрес начала поля на экране
MITEMS:
	.WORD	060,  9.,  9.,  3., <103604+<80.*36.>+8.>
	.WORD	061,  9.,  9., 10., <103604+<80.*36.>+8.>
	.WORD	062, 13., 10., 20., <103604+<80.*28.>+4>
	.WORD	063, 16., 14., 43., <103604+<80.*4>+1>
	.WORD	0

GAMESC:	; Строка подготовки игрового экрана
	.BYTE	033,246,62	; Формат экрана 40x24
	.BYTE	033,240,61	; Цвет символа
	.BYTE	033,241,60	; Цвет знакоместа 0
	.BYTE	033,242,60	; Цвет фона 0
	.BYTE	14		; Clear screen
	.BYTE	033,131,67,40	; Курсор в позицию
	.BYTE	0
EXITSC:	; Строка очистки экрана перед выходом
	.BYTE	033,246,061	; Формат экрана 80x24
	.BYTE	033,240,67	; Цвет символа
	.BYTE	033,241,61	; Цвет знакоместа 1
	.BYTE	033,242,61	; Цвет фона 1
	.BYTE	14		; Очистить экран
	.BYTE	0
MENUSC: ; Текст меню
	.BYTE	033,240,64	; Цвет символа
	.BYTE	033,131,52,54	; Курсор в позицию
	.ASCII	/0. Лошара/
	.BYTE	033,131,53,54	; Курсор в позицию
	.ASCII	/1. Новичок/
	.BYTE	033,131,54,54	; Курсор в позицию
	.ASCII	/2. Любитель/
	.BYTE	033,131,55,54	; Курсор в позицию
	.ASCII	/3. Профессионал/
	.BYTE	033,131,56,54	; Курсор в позицию
	.ASCII	/X. Выход/
	.BYTE	033,240,62	; Цвет символа
	.BYTE	033,131,65,52	; Курсор в позицию
	.ASCII	/БК версия 2012 VINXRU/
	.BYTE	033,131,66,50	; Курсор в позицию
	.ASCII	/УКНЦ версия 2023 nzeemin/
	.BYTE	033,240,61	; Цвет символа
	.BYTE	033,131,67,54	; Курсор в позицию
.INCLUDE /VERSIO.MAC/
	.BYTE	0
	.EVEN

; Начало игры; R5 указывает на строку таблицы MITEMS после клавиши
STGAME:
; Параметры игрового поля
	MOV	(R5)+, GMEWID
	MOV	(R5)+, GMEHEI
	MOV	(R5)+, BOMBCN
	MOV	(R5)+, FSCADR
; Подготовка игрового экрана
	MOV	#GAMESC, R1	; Строка для подготовки игрового экрана
	CALL	PRINT
	CALL	PAUSE
	CALL	DRBLOCKS	; Заполнение фона
; Устанавливаем курсор в центр поля
	MOV	GMEWID, R0
	ASR	R0
	MOV	R0, CURSRX
	MOV	GMEHEI, R0
	ASR	R0
	MOV	R0, CURSRY
; Очистка основных переменных
	CLR	BOMBPT
	CLR	TIME
; Очистка игрового поля
	MOV	#<MAXFLD+36.>, R4	; Счётчик
	MOV	#FIELD0, R0
10$:	MOVB	#200, (R0)+	; Заполнение байта FIELD
	SOB	R4, 10$
	CALL	PUTBOMBS

; Вывод смайлика
	MOV	#SPGOOD, R2
	MOV	#100023, R3
	CALL	SPR24

; Рисование игрового поля
	CALL	DRFIELD

;TODO: Вывод чисел

GMLOOP:
; Проверяем условия окончания игры
	CALL	CHKFLD
	BNE	5$
	JMP	GMEWIN
; Нажата ли клавиша
5$:	CALL	WTKEY
	CMP	#130, R0	; 'X'
	BNE	10$
	JMP	MENU		; Возврат в меню
10$:	CMP	#15504, R0	; Клавиша влево?
	BEQ	GOLEFT
	CMP	#15503, R0	; Клавиша вправо?
	BEQ	GORIGHT
	CMP	#15501, R0	; Клавиша вверх?
	BEQ	GOUP
	CMP	#15502, R0	; Клавиша вниз?
	BEQ	GODOWN
	CMP	#040, R0	; Клавиша пробел?
	BEQ	GOSPC
; Любая другая клавиша - поставить/снять флаг/вопрос
	CALL	CUR2FLD		; R1 = адрес в FIELD
	MOVB	(R1), R0
	BPL	GMLOOP		; Ячейка уже открыта? => ничего не делаем
	MOV	R0, R2
	BIC	#177637, R2	; Оставляем биты 140 - признаки флажка и вопроса
	BEQ	20$		; нет флагов
	BIT	#100, R2
	BEQ	22$
; стоит флажок - меняем на вопрос
	BIC	#140, R0
	BIS	#040, R0
	BR	25$
; нет флагов - меняем на флажок
20$:	BIS	#100, R0
	BR	25$
; знак вопроса - меняем на пусто
22$:	BIC	#140, R0
25$:	MOVB	R0, (R1)	; записываем изменение флагов
	CALL	DRCURC		; Рисуем ячейку под курсором и курсор
	BR	GMLOOP
; Обработка клавиш-стрелок
GOLEFT:
	MOV	CURSRX, R0
	BEQ	GMLOOP
	CALL	DRCURS
	DEC	CURSRX
	CALL	DRCURS
	BR	GMLOOP
GORIGHT:
	MOV	CURSRX, R0
	INC	R0
	CMP	GMEWID, R0
	BLOS	GMLOOP
	CALL	DRCURS
	INC	CURSRX
	CALL	DRCURS
	BR	GMLOOP
GOUP:
	MOV	CURSRY, R0
	BEQ	GMLOOP
	CALL	DRCURS
	DEC	CURSRY
	CALL	DRCURS
	BR	GMLOOP
GODOWN:
	MOV	CURSRY, R0
	INC	R0
	CMP	GMEHEI, R0
	BLOS	GMLOOP
	CALL	DRCURS
	INC	CURSRY
	CALL	DRCURS
	BR	GMLOOP
; Клавиша пробел - открыть ячейку
GOSPC:
	CALL	CUR2FLD		; R1 = адрес в FIELD
	MOVB	(R1), R0
	BPL	GMLOOP		; Ячейка уже открыта? => ничего не делаем
	MOV	#177600, R2
	XOR	R2, R0		; Меняем признак "ячейка открыта"
	MOVB	R0, (R1)
	PUSH	R0
	CALL	DRCURC		; Рисуем ячейку под курсором и курсор
	POP	R0
	BNE	10$		; ячейка пуста?
; Ячейка пуста - раскрываем область вокруг неё
	MOV	CURSRX, R0
	MOV	CURSRY, R1
	CALL	OPENAREA
	BR	GMLOOP
10$:	BIT	#20, R0		; Это мина?
	BEQ	GMLOOP		; нет
	JMP	GMEOVR		; Это мина, игра окончена

; Текущая ячейка пуста и уже открыта, раскрываем свободную область вокруг неё, рекурсия
; R0 = X, R1 = Y
OPENAREA:
	MOV	R1, R3		; сохраняем строку
	CALL	XY2FLD		; R1 = адрес в FIELD
	MOV	R1, R2
	MOV	R3, R1		; R0 = X, R1 = Y, R2 = адрес в FIELD
; влево
	TST	R0		; колонка 0?
	BEQ	15$		; пропускаем проверку слева
	DEC	R0
	DEC	R2
	BITB	#200, (R2)	; открыта?
	BEQ	10$
	BITB	#160, (R2)	; можно открыть?
	BNE	10$
	CALL	OPENCELL
10$:
; влево-вверх
	TST	R1		; строка 0?
	BEQ	12$		; пропускаем проверку влево-вверх
	SUB	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	11$
	BITB	#160, (R2)	; можно открыть?
	BNE	11$
	DEC	R1
	CALL	OPENCELL
	INC	R1
11$:	ADD	#18., R2
12$:
; влево-вниз
	INC	R1
	CMP	GMEHEI, R1	; последняя строка?
	BEQ	14$
	ADD	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	13$
	BITB	#160, (R2)	; можно открыть?
	BNE	13$
	CALL	OPENCELL
13$:	SUB	#18., R2
14$:	DEC	R1
; восстанавливаем после влево
	INC	R0
	INC	R2
15$:
; вверх
	TST	R1		; строка 0?
	BEQ	25$		; пропускаем проверку вверх
	SUB	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	24$
	BITB	#160, (R2)	; можно открыть?
	BNE	24$
	DEC	R1
	CALL	OPENCELL
	INC	R1
24$:	ADD	#18., R2
25$:
; вправо
	INC	R2
	INC	R0
	CMP	GMEWID, R0	; последняя колонка?
	BEQ	38$
	BITB	#200, (R2)	; открыта?
	BEQ	28$
	BITB	#160, (R2)	; можно открыть?
	BNE	28$
	CALL	OPENCELL
28$:
; вправо-вверх
	TST	R1		; строка 0?
	BEQ	30$		; пропускаем проверку вверх
	SUB	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	29$
	BITB	#160, (R2)	; можно открыть?
	BNE	29$
	DEC	R1
	CALL	OPENCELL
	INC	R1
29$:	ADD	#18., R2
30$:
; вправо-вниз
	INC	R1
	CMP	GMEHEI, R1	; последняя строка?
	BEQ	37$
	ADD	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	36$
	BITB	#160, (R2)	; можно открыть?
	BNE	36$
	CALL	OPENCELL
36$:	SUB	#18., R2
37$:	DEC	R1
; Восстанавливаем после вправо
38$:	DEC	R0
	DEC	R2
; вниз
	INC	R1
	CMP	GMEHEI, R1	; последняя строка?
	BEQ	45$
	ADD	#18., R2
	BITB	#200, (R2)	; открыта?
	BEQ	44$
	BITB	#160, (R2)	; можно открыть?
	BNE	44$
	CALL	OPENCELL
44$:	SUB	#18., R2
45$:	DEC	R1
	RETURN

; Открыть пустую ячейку, с рекурсивным открытием дальше
; R0 = X, R1 = Y, R2 = адрес в FIELD
OPENCELL:
	BICB	#200, (R2)	; Очистить верхний бит в FIELD - открываем
	PUSH	R2
	PUSH	R0
	PUSH	R1
; Перерисовать ячейку
	CALL	CELL2SCR	; R1 = адрес на экране
	MOV	R1, R3
	MOVB	(R2), R0
	PUSH	R0		; сохраняем содержимое ячейки
	CALL	DRCELL
	POP	R0		; содержимое ячейки пусто?
	BNE	5$		; нет => не продолжаем рекурсию
; Ячейка пуста - продолжаем рекурсивное раскрытие
	POP	R1		; Y
	POP	R0		; X
	PUSH	R0
	PUSH	R1
	CALL	OPENAREA	; Продолжить рекурсию по соседним клеткам
5$:	POP	R1		; Y
	POP	R0		; X
	POP	R2		; адрес в FIELD
	RETURN

PUTBOMBS:
	MOV	BOMBCN, R5	; Счётчик цикла - сколько мин поставить
1$:	PUSH	R5
2$:	CALL	RANDOM		; R3 = случайное число
	BIC	#100000, R3	; убираем знак
	MOV	R3, R1
	CLR	R0
	DIV	GMEWID, R0	; R0 = частное, R1 = остаток = X
	PUSH	R1		; сохраняем X
	CALL	RANDOM		; R3 = случайное число
	BIC	#100000, R3	; убираем знак
	MOV	R3, R1
	CLR	R0
	DIV	GMEHEI, R0	; R0 = частное, R1 = остаток = Y
	POP	R0		; теперь R0 = X, R1 = Y
	CALL	XY2FLD
	BITB	#20, (R1)	; Мина уже стоит?
	BNE	2$		; да => ищем другое место
	MOVB	#237, (R1)	; ставим мину
	;MOVB	#037, (R1);DEBUG
	INC	BOMBPT		; количество мин на поле
	POP	R5
	SOB	R5, 1$
; Мины поставлены, теперь вычисляем количество мин вокруг каждой ячейки
	MOV	#FIELD, R2
	CLR	R4		; Номер строки
11$:
	PUSH	R4
	PUSH	R2
	CLR	R3		; Номер столбца
12$:
	MOVB	(R2), R0	; Содержимое клетки
	BIT	#20, R0		; это мина?
	BNE	15$		; да => пропускаем всё
; Для ячейки (R2) считаем количество мин
	CALL	BOMBCALC
15$:	INC	R2
; Завершение циклов по строке и по строкам
	INC	R3
	CMP	GMEWID, R3
	BNE	12$		; Продолжаем цикл по строке
	POP	R2
	ADD	#18., R2	; к следующей строке FIELD
	POP	R4
	INC	R4
	CMP	GMEHEI, R4
	BNE	11$		; Продолжаем цикл по строкам
	RETURN

; Подсчёт мин вокруг пусто ячейки; R2 = адрес в FIELD
; R3 = колонка, R4 = строка
; Записывает результат в (R2)
BOMBCALC:
	PUSH	R2		; сохраняем адрес в FIELD
	CLR	R0		; Счётчик мин вокруг
; Столбец слева
	DEC	R2
	BITB	#20, (R2)	; мина слева?
	BEQ	13$
	INC	R0
13$:
; влево-вверх
	SUB	#18., R2
	BITB	#20, (R2)	; мина слева-вверху?
	BEQ	14$
	INC	R0
14$:	ADD	#18., R2
; влево-вниз
	ADD	#18., R2
	BITB	#20, (R2)	; мина слева-вверху?
	BEQ	15$
	INC	R0
; Вверх
15$:	MOV	(SP), R2	; восстанавливаем адрес в FIELD
	SUB	#18., R2	; на строку выше
	BITB	#20, (R2)	; мина сверху?
	BEQ	16$
	INC	R0
16$:	MOV	(SP), R2	; восстанавливаем адрес в FIELD
	INC	R3		; на столбец вправо
; Столбец справа
	INC	R2
	BITB	#20, (R2)	; мина справа?
	BEQ	17$
	INC	R0
; вправо-вверх
17$:	SUB	#18., R2
	BITB	#20, (R2)	; мина справа-вверху?
	BEQ	18$
	INC	R0
18$:	ADD	#18., R2
; вправо-вниз
	ADD	#18., R2
	BITB	#20, (R2)	; мина справа-внизу?
	BEQ	20$
	INC	R0
20$:	SUB	#18., R2

	MOV	(SP), R2	; восстанавливаем адрес в FIELD
 	DEC	R3		; восстанавливаем столбец
; Вниз
	ADD	#18., R2
	BITB	#20, (R2)	; мина внизу?
	BEQ	26$
	INC	R0
26$:
; Мины вокруг подсчитаны, сохраняем их количество
	POP	R2
	BISB	R0, (R2)	; Записываем число мин вокруг ячейки
	;MOVB	R0, (R2);DEBUG
	RETURN

; Проверка поля на завершение
; Результат: Z=1 - игра окончена
CHKFLD:
	MOV	#FIELD, R2
	CLR	R4		; Номер строки
11$:
	PUSH	R4
	PUSH	R2
	CLR	R3		; Номер столбца
12$:
	MOVB	(R2)+, R0	; Содержимое клетки
	BIT	#20, R0		; это мина?
	BEQ	15$		; нет
; Это мина, проверяем что на ней флажок
	BIC	#37, R0
	CMPB	#300, R0	; это флажок?
	BNE	40$		; нет, игра не окончена
	BR	20$
; Это не мина, проверяем что ячейка раскрыта
15$:	BIT	#200, R0
	BNE	40$		; нет, игра не окончена
; Завершение циклов по строке и по строкам
20$:	INC	R3
	CMP	GMEWID, R3
	BNE	12$		; Продолжаем цикл по строке
	POP	R2
	ADD	#18., R2	; к следующей строке FIELD
	POP	R4
	INC	R4
	CMP	GMEHEI, R4
	BNE	11$		; Продолжаем цикл по строкам
; Раз мы всё проверили, значит, игра окончена
	SEZ
	RETURN
; Что-то не так, игра не окончена
40$:	POP	R2
	POP	R4
	CLZ
	RETURN

; Игра окончена, игрок выиграл
GMEWIN:
	MOV	#SPWIN, R2
; Нарисовать иконку, показать все мины, вернуться в меню
	BR	GMEOV1

; Игра окончена, игрок проиграл
GMEOVR:
	MOV	#SPBAD, R2
GMEOV1:	MOV	#100023, R3
	CALL	SPR24
; Раскрыть все мины
	MOV	#FIELD, R2
	MOV	#MAXFLD, R4
10$:	MOVB	(R2), R0
	BIT	#20, R0
	BEQ	12$
	BICB	#340, R0
	MOVB	R0, (R2)
12$:	INC	R2
	SOB	R4, 10$
; Отрисовать поле
	CALL	DRFIELD
; Ждём клавиши и выходим в меню
	CALL	WTKEY
	JMP	MENU

; Перевести R0 = X, R1 = Y в адрес в FIELD
; результат в R1
XY2FLD:
	MUL	#18., R1
	ADD	R0, R1
	ADD	#FIELD, R1
	RETURN

; Перевести координаты курсора в адрес в FIELD
; результат в R1
CUR2FLD:
	MOV	CURSRY, R1
	MUL	#18., R1
	ADD	CURSRX, R1
	ADD	#FIELD, R1
	RETURN

; Перевести координаты курсора в адрес на экране
CUR2SCR:
	MOV	CURSRX, R0
	MOV	CURSRY, R1
; Перевести R0=X и R1=Y в адрес на экране
; результат в R1
CELL2SCR:
	MUL	#<80.*16.>, R1
	ASL	R0
	ADD	R0, R1
	ADD	FSCADR, R1
	RETURN

; Нарисовать ячейку под курсором и курсор
DRCURC:
	CALL	CUR2SCR		; R1 = адрес на экране
	MOV	R1, R3
	CALL	CUR2FLD		; R1 = адрес в FIELD
	MOVB	(R1), R0
	CALL	DRCELL		; Нарисовать ячейку
	JMP	DRCURS		; Нарисовать курсор

; Нарисовать ячейку игрового поля
; R0 = содержимое ячейки, R3 = адрес на экране
DRCELL:
	TSTB	R0
	BPL	5$
; Ячейка закрыта
	BIT	#100, R0
	BEQ	1$
; Флажок
	MOV	#SPFLAG, R2
	JMP	SPR16
1$:	BIT	#040, R0
	BEQ	2$
; Знак вопроса
	MOV	#SPQSGN, R2
	JMP	SPR16
; Просто закрытая ячейка
2$:	MOV	#SPUNKN, R2
	JMP	SPR16
; Ячейка открыта
5$:	BIT	#20, R0
	BEQ	6$
	MOV	#SPMINE, R2	; Мина
	JMP	SPR16
; Число мин вокруг 0..8
6$:	MOV	R0, R2
	ASL	R2
	ASL	R2
	ASL	R2
	ASL	R2
	ASL	R2
	ASL	R2
	ADD	#SP0, R2
	JMP	SPR16

; Нарисовать игровое поле
DRFIELD:
	MOV	FSCADR, R3	; Адрес начала игрового поля на экране
	MOV	#FIELD, R2
	MOV	GMEHEI, R4	; Счётчик строк
1$:
	PUSH	R4
	PUSH	R3
	MOV	GMEWID, R4	; Счётчик столбцов
	PUSH	R2		; адрес в FIELD
2$:
	PUSH	R4
	PUSH	R3
	MOVB	(R2)+, R0	; Содержимое клетки
	PUSH	R2
	CALL	DRCELL		; Рисуем клетку
	POP	R2
	POP	R3
	INC	R3
	INC	R3
	POP	R4
	SOB	R4, 2$
; Завершение цикла по строкам
	POP	R2		; адрес в FIELD
	ADD	#18., R2	; К следующей строке FIELD
	POP	R3
	ADD	#<80.*16.>, R3	; К следующей строке экрана
	POP	R4
	SOB	R4, 1$
; Нарисовать курсор
	CALL	DRCURS
	RETURN

; Нарисовать фон
DRBLOCKS:
	MOV	#<103600+4>, R3
	MOV	#17., R0	; Счётчик столбцов
1$:	PUSH	R0
	PUSH	R3
	MOV	#14., R4	; Счётчик строк
2$:	MOV	#SPBLOCK, R2
	CALL	SPR16
	SOB	R4, 2$
	POP	R3
	INC	R3
	INC	R3
	POP	R0
	SOB	R0, 1$
	RETURN

; Вывести битмап с названием игры
DRLOGO:
	MOV	#SPLOGO, R2
	MOV	#36., R5
	MOV	#103612, R3
1$:
	MOV	#16., R4
2$:
	MOV	R3, @#176640
	MOV	(R2)+, @#176642
	INC	R3
	SOB	R4, 2$
	ADD	#<80.-16.>, R3	; next line
	SOB	R5, 1$
	RETURN

; Вывод спрайта 16 x 16 пикселей
;     R2 = адрес спрайта, R3 = адрес на экране
;     Портит R5, R2, R3
SPR16:
	MOV	#16., R5	; Количество строк
1$:
	MOV	R3, @#176640
	MOV	(R2)+, @#176642	; Первое слово
	INC	R3
	MOV	R3, @#176640
	MOV	(R2)+, @#176642	; Второе слово
	ADD	#<80.-1>, R3	; next line
	SOB	R5, 1$
	RETURN

; Нарисовать спрайт курсора
DRCURS:
	CALL	CUR2SCR
	MOV	R1, R3
	MOV	#SPCURS, R2
	;JMP	SPR16X

; Вывод спрайта 16 x 16 пикселей по XOR
;     R2 = адрес спрайта, R3 = адрес на экране
;     Портит R5, R2, R3, R0
SPR16X:
	MOV	#16., R5	; Количество строк
1$:
	MOV	R3, @#176640
	MOV	(R2)+, R0
	XOR	R0, @#176642	; Первое слово
	INC	R3
	MOV	R3, @#176640
	MOV	(R2)+, R0
	XOR	R0, @#176642	; Второе слово
	ADD	#<80.-1>, R3	; next line
	SOB	R5, 1$
	RETURN

; Вывод спрайта 24 x 24 пикселей
;     R2 = адрес спрайта, R3 = адрес на экране
SPR24:
	MOV	#24., R5	; Количество строк
1$:
	MOV	R3, @#176640
	MOV	(R2)+, @#176642	; Первое слово
	INC	R3
	MOV	R3, @#176640
	MOV	(R2)+, @#176642	; Второе слово
	INC	R3
	MOV	R3, @#176640
	MOV	(R2)+, @#176642	; Третье слово
	ADD	#<80.-2>, R3	; next line
	SOB	R5, 1$
	RETURN

; Подпрограмма: Печать строки: R1 = адрес строки, строка завершается 0; портит R0
; После завершения R1 указывает на байт следующий за 0
PRINT:
10$:	MOVB	(R1)+, R0	; Конец строки?
	BEQ	RETN		; да => выходим
20$:	TSTB	@#177564	; Источник канала 0 готов?
	BPL	20$		; нет => ждём
	MOV	R0, @#177566	; передаём символ в канал 0
	BR	10$

; Подпрограмма: пауза после очистки экрана чтобы ПП закончил работу
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
1$:	NOP
	SOB	R5, 1$
RETN:	RETURN

; Подпрограмма: Ожидание символа с клавиатуры: R0 = полученный символ
WTKEY:	TSTB	@#177560
	BPL	WTKEY
	CLR	R0
	MOVB	@#177562, R0	; символ в R0
	CMPB	R0, #33
	BNE	RETN
ESCKEY:	TSTB	@#177560
	BPL	ESCKEY
	MOVB	@#177562, R0	; символ в R0
	BIS	#15400,R0	; #33 в верхний байт
	RETURN
; Подпрограмма: Получение символа с клавиатуры: флаг Z=0 = есть символ, R0 = полученный символ
GETKEY:	TSTB	@#177560	; есть символ?
	BPL	10$		; нет символа => выходим
	MOVB	@#177562, R0	; символ в R0
	CMPB	R0, #33		; Esc ?
	BEQ	ESCKEY
	RETURN
10$:	CLR	R0		; возвращаем пустой код клавиши
	RETURN

; Routine: Get pseudo-random number, result in R3
; (copied from uknc-highwayencounter code)
RANDOM:
	MOV	RANDSD, R2	; A270	LD DE,($5C76)	; Read RND SEED variable
	MOV	R2, R3		; A274	LD H,E
	SWAB	R3
	BIC	#377, R3
	ADD	#375, R3	; A275	LD L,$FD
	MOV	R2, R0		; A277	LD A,D
	SWAB	R0
	BIC	#177400, R0	; A278	OR A
	SUB	R2, R3		; A279	SBC HL,DE
	SBCB	R0		; A27B	SBC A,$00
	SUB	R2, R3		; A27D	SBC HL,DE
	SBCB	R0		; A27F	SBC A,$00
				; A281	LD E,A
	BIC	#177400, R0	; A282	LD D,$00
	SUB	R0, R3		; A284	SBC HL,DE
	BHIS	LA289		; A286	JR NC,$A289
	INC	R3		; A288	INC HL
LA289:	MOV	R3, RANDSD	; A289	LD ($5C76),HL	; Write RND SEED variable
	RETURN			; A28C	RET
RANDSD:	.WORD	123456		; Pseudo-random seed

.INCLUDE /TILES.MAC/

GMEWID:	.WORD	0		; Ширина игрового поля в клетках
GMEHEI:	.WORD	0		; Высота игрового поля в клетках
CURSRX:	.WORD	0
CURSRY:	.WORD	0
FSCADR:	.WORD	103600
BOMBCN:	.WORD	0		; Количество мин на этом уровне игры
BOMBPT:	.WORD	0		; Сколько мин сейчас на игровом поле
TIME:	.WORD	0
; Игровое поле; со всех сторон обрамлено свободным местом минимум в 1 ячейку
FIELD0:	.BLKB	18.		; Пустое пространство перед полем
FIELD:	.BLKB	MAXFLD
	.BLKB	18.		; Пустое пространство после поля

STACK::	.BLKW	400		; Под стек

	.END	START
